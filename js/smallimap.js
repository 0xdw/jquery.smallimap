// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function($) {
    var BlipEvent, ColorEffect, DelayEffect, Effect, Event, RadiusEffect, Smallimap;
    $.si || ($.si = {});
    $.si.smallimap = {
      version: '0.1',
      defaults: {
        colors: {
          lights: ["#fdf6e3", "#eee8d5", "#b8b0aa", "#93a1a1", "#839496"],
          darks: ["#002b36", "#073642", "#586e75", "#657b83"],
          land: {
            day: function(smallimap) {
              return smallimap.colors.lights.slice(1).concat(smallimap.colors.darks.slice(1).reverse());
            },
            night: function(smallimap) {
              return smallimap.colors.land.day().reverse();
            }
          }
        }
      }
    };
    Smallimap = (function() {

      function Smallimap(cwidth, cheight, renderContext, world, options) {
        if (options == null) {
          options = {};
        }
        this.newEvent = __bind(this.newEvent, this);

        this.createChangers = __bind(this.createChangers, this);

        this.newMouseHover = __bind(this.newMouseHover, this);

        this.triggerOverlay = __bind(this.triggerOverlay, this);

        this.setColor = __bind(this.setColor, this);

        this.setRadius = __bind(this.setRadius, this);

        this.reset = __bind(this.reset, this);

        this.markDirty = __bind(this.markDirty, this);

        this.render = __bind(this.render, this);

        this.landinessOf = __bind(this.landinessOf, this);

        this.convertToWorldY = __bind(this.convertToWorldY, this);

        this.convertToWorldX = __bind(this.convertToWorldX, this);

        this.colorFor = __bind(this.colorFor, this);

        this.dot = __bind(this.dot, this);

        this.generateGrid = __bind(this.generateGrid, this);

        this.refresh = __bind(this.refresh, this);

        this.run = __bind(this.run, this);

        this.world = world;
        this.dotRadius = 3.2;
        this.dotDiameter = this.dotRadius * 2;
        this.width = cwidth / this.dotDiameter;
        this.height = cheight / this.dotDiameter;
        this.lastX = -1;
        this.lastY = -1;
        this.dirtyXs = void 0;
        this.eventQueue = [];
        this.lastRefresh = 0;
        this.fps = 20;
        this.renderContext = renderContext;
        $.extend(true, this, $.si.smallimap.defaults, options);
        this.grid = this.generateGrid(this.width, this.height);
      }

      Smallimap.prototype.run = function() {
        return this.refresh();
      };

      Smallimap.prototype.refresh = function() {
        var event, i, now, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
        now = new Date();
        for (i = _i = 0, _ref = this.eventQueue.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (!(i)) {
            continue;
          }
          event = this.eventQueue.shift();
          event(now);
        }
        if (!this.dirtyXs) {
          this.dirtyXs = [];
          for (x = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            this.dirtyXs[x] = true;
          }
        }
        for (x = _k = 0, _ref2 = this.width - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; x = 0 <= _ref2 ? ++_k : --_k) {
          if (this.dirtyXs[x]) {
            this.dirtyXs[x] = false;
            for (y = _l = 0, _ref3 = this.height - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; y = 0 <= _ref3 ? ++_l : --_l) {
              if (this.grid[x][y].dirty) {
                this.render(x, y);
              }
            }
          }
        }
        return requestAnimationFrame(this.refresh);
      };

      Smallimap.prototype.generateGrid = function(width, height) {
        var grid, x, y, _i, _j, _ref, _ref1;
        grid = [];
        for (x = _i = 0, _ref = width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
          for (y = _j = 0, _ref1 = height - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            grid[x] || (grid[x] = []);
            grid[x][y] = this.dot(x, y, this.landinessOf(x, y));
          }
        }
        return grid;
      };

      Smallimap.prototype.dot = function(x, y, landiness) {
        var newDot;
        newDot = {
          x: x,
          y: y,
          landiness: landiness,
          initial: {
            color: this.colorFor(this.xToLong(x), this.yToLat(y), landiness),
            radius: this.dotRadius * 0.64
          },
          target: {},
          dirty: true
        };
        return newDot;
      };

      Smallimap.prototype.longToX = function(longitude) {
        return Math.floor((longitude + 180) * this.width / 360 + 0.5);
      };

      Smallimap.prototype.latToX = function(latitude) {
        return Math.floor((-latitude + 90) * this.height / 180 + 0.5);
      };

      Smallimap.prototype.xToLong = function(x) {
        return Math.floor(x * 360 / this.width - 180 + 0.5);
      };

      Smallimap.prototype.yToLat = function(y) {
        return -Math.floor(y * 180 / this.height - 90 + 0.5);
      };

      Smallimap.prototype.colorFor = function(longitude, latitude, landiness) {
        var darkness, idx, landColors, now, sunSet;
        darkness = landiness * landiness;
        now = new Date();
        sunSet = new SunriseSunset(now.getYear(), now.getMonth() + 1, now.getDate(), latitude, longitude);
        landColors = this.colors.land.day(this);
        idx = Math.floor(darkness * (landColors.length - 2));
        if (sunSet.isDaylight(now.getHours())) {
          return new Color(landColors[idx]);
        } else {
          return new Color(landColors[idx + 1]);
        }
      };

      Smallimap.prototype.convertToWorldX = function(x) {
        return Math.floor(x * this.world.length / this.width);
      };

      Smallimap.prototype.convertToWorldY = function(y) {
        return Math.floor(y * this.world[0].length / this.height);
      };

      Smallimap.prototype.landinessOf = function(x, y) {
        var existsCount, i, j, totalCount, worldXEnd, worldXStart, worldYEnd, worldYStart, _i, _j;
        worldXStart = this.convertToWorldX(x);
        worldXEnd = this.convertToWorldX(x + 1) - 1;
        worldYStart = this.convertToWorldY(y);
        worldYEnd = this.convertToWorldY(y + 1) - 1;
        totalCount = 0;
        existsCount = 0;
        for (i = _i = worldXStart; worldXStart <= worldXEnd ? _i <= worldXEnd : _i >= worldXEnd; i = worldXStart <= worldXEnd ? ++_i : --_i) {
          for (j = _j = worldYStart; worldYStart <= worldYEnd ? _j <= worldYEnd : _j >= worldYEnd; j = worldYStart <= worldYEnd ? ++_j : --_j) {
            totalCount += 1;
            if (this.world[i] && this.world[i][j]) {
              existsCount += 1;
            }
          }
        }
        return existsCount / totalCount;
      };

      Smallimap.prototype.render = function(x, y, millis) {
        var color, dot, radius;
        dot = this.grid[x][y];
        color = dot.target.color || dot.initial.color;
        radius = dot.target.radius || dot.initial.radius;
        this.renderContext.clearRect(x * this.dotDiameter, y * this.dotDiameter, this.dotDiameter, this.dotDiameter);
        this.renderContext.fillStyle = color.rgbString();
        this.renderContext.beginPath();
        this.renderContext.arc(x * this.dotDiameter + this.dotRadius, y * this.dotDiameter + this.dotRadius, radius, 0, Math.PI * 2, true);
        this.renderContext.closePath();
        this.renderContext.fill();
        dot.dirty = false;
        return dot.target = {};
      };

      Smallimap.prototype.markDirty = function(x, y) {
        if (this.dirtyXs) {
          this.dirtyXs[x] = true;
        }
        return this.grid[x][y].dirty = true;
      };

      Smallimap.prototype.reset = function(x, y) {
        return this.markDirty(x, y);
      };

      Smallimap.prototype.setRadius = function(x, y, r) {
        var target;
        target = this.grid[x][y].target;
        if (target.radius) {
          target.radius = (target.radius + r) / 2;
        } else {
          target.radius = r;
        }
        return this.markDirty(x, y);
      };

      Smallimap.prototype.setColor = function(x, y, color) {
        var target;
        target = this.grid[x][y].target;
        if (target.color) {
          target.color = target.color.mix(color);
        } else {
          target.color = color;
        }
        return this.markDirty(x, y);
      };

      Smallimap.prototype.triggerOverlay = function() {
        var push, y, _i, _ref, _results,
          _this = this;
        y = 0;
        push = function(x, diff) {
          var dot, r, setDots;
          dot = _this.grid[x][0];
          r = dot.initial.radius;
          setDots = function(r) {
            var _i, _ref, _results;
            _results = [];
            for (y = _i = 0, _ref = _this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
              _results.push(_this.setRadius(x, y, r));
            }
            return _results;
          };
          return _this.eventQueue.push(function() {
            setDots(r + diff);
            return setTimeout(function() {
              setDots(r);
              return _this.eventQueue.push(function() {
                return push((x + 1) % _this.width, diff);
              });
            }, 1000 / _this.width * 8);
          });
        };
        _results = [];
        for (y = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
          _results.push(push(0, 0.5));
        }
        return _results;
      };

      Smallimap.prototype.newMouseHover = function(px, py) {
        var d, dot, i, j, lastX, lastY, pushDown, radius, x, y, _i, _j;
        x = Math.floor(px / this.dotDiameter);
        y = Math.floor(py / this.dotDiameter);
        radius = 2;
        pushDown = function(x, y, initial, target) {
          return true;
        };
        if (this.grid[x] && this.grid[x][y]) {
          if (this.lastX !== x && this.lastY !== y) {
            dot = this.grid[x][y];
            for (i = _i = -radius; -radius <= radius ? _i <= radius : _i >= radius; i = -radius <= radius ? ++_i : --_i) {
              for (j = _j = -radius; -radius <= radius ? _j <= radius : _j >= radius; j = -radius <= radius ? ++_j : --_j) {
                d = Math.sqrt(i * i + j * j);
                if (d < radius) {
                  pushDown(x + i, y + j, dot.initial.radius, 2);
                }
              }
            }
            lastX = x;
            return lastY = y;
          }
        }
      };

      Smallimap.prototype.createChangers = function(x, y, startColor, targetColor, colorWeight, startRadius, targetRadius, delay, length) {
        var _this = this;
        return setTimeout(function() {
          _this.eventQueue.push(_this.events.changeColor(_this, x, y, startColor, targetColor, colorWeight, Math.min(512, length), function() {
            return _this.eventQueue.push(_this.events.changeColor(_this, x, y, targetColor, startColor, 1, length, function() {
              return true;
            }));
          }));
          return _this.eventQueue.push(_this.events.changeRadius(_this, x, y, startRadius, targetRadius, Math.min(512, length), function() {
            return _this.eventQueue.push(_this.events.changeRadius(_this, x, y, targetRadius, startRadius, length, function() {
              return true;
            }));
          }));
        }, delay);
      };

      Smallimap.prototype.newEvent = function(event) {
        var d, delay, dot, i, j, length, nx, ny, radius, targetColor, targetRadius, x, y, _i, _results;
        x = this.longToX(event.longitude);
        y = this.latToX(event.latitude);
        radius = event.radius || 5;
        _results = [];
        for (i = _i = -radius; -radius <= radius ? _i <= radius : _i >= radius; i = -radius <= radius ? ++_i : --_i) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (j = _j = -radius; -radius <= radius ? _j <= radius : _j >= radius; j = -radius <= radius ? ++_j : --_j) {
              nx = x + i;
              ny = y + j;
              d = Math.sqrt(i * i + j * j);
              if (nx >= 0 && ny >= 0 && nx < this.width && ny < this.height && d < radius) {
                dot = this.grid[nx][ny];
                delay = event.length * (d / radius);
                length = event.length - delay;
                targetColor = new Color(event.color);
                targetRadius = (this.dotRadius - dot.initial.radius) / (d + 1) + dot.initial.radius;
                if (length > 0) {
                  _results1.push(this.createChangers(nx, ny, dot.initial.color, targetColor, 1 - d / radius, dot.initial.radius, targetRadius, delay, length));
                } else {
                  _results1.push(void 0);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      };

      Smallimap.prototype.events = {
        changeColor: function(smallimap, x, y, start, target, weight, length, onComplete) {
          var startTime, updater;
          startTime = new Date().getTime();
          updater = function(now) {
            var diff, frameWeight;
            diff = now.getTime() - startTime;
            frameWeight = weight * diff / length;
            smallimap.setColor(x, y, new Color(start.rgbString()).mix(target, weight));
            if (diff < length) {
              return smallimap.eventQueue.push(updater);
            } else {
              return onComplete();
            }
          };
          return updater;
        },
        changeRadius: function(smallimap, x, y, start, target, length, onComplete) {
          var startTime, updater;
          startTime = new Date().getTime();
          updater = function(now) {
            var diff;
            diff = now.getTime() - startTime;
            if (diff < length) {
              smallimap.setRadius(x, y, target * diff / length + start * (1 - diff / length));
              return smallimap.eventQueue.push(updater);
            } else {
              smallimap.setRadius(x, y, target);
              return onComplete();
            }
          };
          return updater;
        }
      };

      return Smallimap;

    })();
    Effect = (function() {

      function Effect(dot, duration, options) {
        this.dot = dot;
        this.duration = duration;
        this.refresh = __bind(this.refresh, this);

        this.withEasing = __bind(this.withEasing, this);

        this.update = __bind(this.update, this);

        this.timeElapsed = 0;
        this.easing = options.easing || this.linearEasing;
        this.callback = options.callback;
      }

      Effect.prototype.linearEasing = function(progress) {
        return progress;
      };

      Effect.prototype.update = function(diff) {
        timeElapsed += diff;
        this.refresh(this.easing(timeElapsed / duration));
        if (timeElapsed > duration) {
          if (typeof this.callback === "function") {
            this.callback();
          }
          return false;
        } else {
          return true;
        }
      };

      Effect.prototype.withEasing = function(easing) {
        return this.easing = easing;
      };

      Effect.prototype.refresh = function(progress) {
        return "unimplemented";
      };

      return Effect;

    })();
    RadiusEffect = (function(_super) {

      __extends(RadiusEffect, _super);

      function RadiusEffect(dot, duration, options) {
        this.refresh = __bind(this.refresh, this);
        RadiusEffect.__super__.constructor.call(this, dot, duration, options);
        this.startRadius = options.startRadius || 6;
        this.endRadius = options.endRadius || 8;
      }

      RadiusEffect.prototype.refresh = function(progress) {
        return this.dot.setRadius(this.endRadius * progress + this.startRadius * (1 - progress));
      };

      return RadiusEffect;

    })(Effect);
    ColorEffect = (function(_super) {

      __extends(ColorEffect, _super);

      function ColorEffect(dot, duration, options) {
        this.refresh = __bind(this.refresh, this);
        ColorEffect.__super__.constructor.call(this, dot, duration, options);
        this.startColor = new Color(options.startColor || "#ff00ff");
        this.endColor = new Color(options.endColor || "#336699");
      }

      ColorEffect.prototype.refresh = function(progress) {
        var start;
        start = new Color(this.startColor.rgbString());
        return this.dot.setColor = start.mix(this.endColor, progress);
      };

      return ColorEffect;

    })(Effect);
    DelayEffect = (function(_super) {

      __extends(DelayEffect, _super);

      function DelayEffect(dot, duration, options) {
        this.refresh = __bind(this.refresh, this);
        DelayEffect.__super__.constructor.call(this, dot, duration, options);
      }

      DelayEffect.prototype.refresh = function(progress) {
        return "nothing to do";
      };

      return DelayEffect;

    })(Effect);
    Event = (function() {

      function Event(smallimap, callback) {
        this.smallimap = smallimap;
        this.callback = callback;
        this.refresh = __bind(this.refresh, this);

        this.init = __bind(this.init, this);

        this.queue = [];
      }

      Event.prototype.enqueue = function(effect) {
        return this.queue.push(effect);
      };

      Event.prototype.init = function() {
        return "no init, dude";
      };

      Event.prototype.refresh = function(dt) {
        var event, ongoingEffects;
        ongoingEffects = [];
        for (event in this.queue) {
          if (event.refresh(dt)) {
            ongoingEffects.push(event);
          }
        }
        this.queue = ongoingEffects;
        return this.queue.length > 0;
      };

      return Event;

    })();
    BlipEvent = (function() {

      function BlipEvent(smallimap, options) {
        this.init = __bind(this.init, this);
        BlipEvent.__super__.constructor.call(this, smallimap, options.callback);
        this.latitude = options.latitude;
        this.longitude = options.longitude;
        this.color = new Color(options.color || "#336699");
        this.radius = options.radius || 8;
        this.weight = options.weight || 0.5;
        this.duration = options.duration || 1024;
      }

      BlipEvent.prototype.init = function() {
        var d, delay, dot, duration, endColor, endRadius, i, j, nx, ny, startColor, startRadius, x, y, _i, _ref, _ref1, _results;
        x = longToX(this.longitude);
        y = latToY(this.latitude);
        _results = [];
        for (i = _i = _ref = -this.radius, _ref1 = this.radius; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref2, _ref3, _results1,
              _this = this;
            _results1 = [];
            for (j = _j = _ref2 = -this.radius, _ref3 = this.radius; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; j = _ref2 <= _ref3 ? ++_j : --_j) {
              nx = x + i;
              ny = y + j;
              d = Math.sqrt(i * i + j * j);
              if (this.smallimap.grid[nx] && this.smallimap.grid[nx][ny]) {
                dot = this.grid[nx][ny];
                delay = this.duration * d / this.radius;
                duration = this.duration - delay;
                startColor = dot.initial.color;
                startRadius = dot.initial.radius;
                endColor = new Color(this.color.rgbString());
                endRadius = (this.dotRadius - startRadius) / (d + 1) + startRadius;
                if (duration > 0) {
                  this.enqueue(new ColorEffect(dot, duration, {
                    startColor: startColor,
                    endColor: endColor,
                    callback: function() {
                      return _this.enqueue(new ColorEffect(dot, duration, {
                        startColor: endColor,
                        endColor: startColor
                      }));
                    }
                  }));
                  _results1.push(this.enqueue(new RadiusEffect(dot, duration, {
                    startRadius: startRadius,
                    endRadius: endRadius,
                    callback: function() {
                      return _this.enqueue(new RadiusEffect(dot, duration, {
                        startRadius: endRadius,
                        endRadius: startRadius
                      }));
                    }
                  })));
                } else {
                  _results1.push(void 0);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      };

      return BlipEvent;

    })();
    return $.fn.smallimap = function(options) {
      if (options == null) {
        options = {};
      }
      options = $.extend({}, $.si.smallimap.defaults, options);
      return this.each(function() {
        var canvas, ctx, self, smallimap;
        self = $(this);
        canvas = this;
        ctx = canvas.getContext('2d');
        smallimap = new Smallimap(canvas.width, canvas.height, ctx, smallimapWorld, options);
        return self.data('api', smallimap);
      });
    };
  })(jQuery);

}).call(this);
